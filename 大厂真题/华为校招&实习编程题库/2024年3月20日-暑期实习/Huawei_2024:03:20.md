# 大厂真题
## 华为
### [2024年3月20日](https://notes.kamacoder.com/questions/502144)
#### 任务要求
#### 华为-2024年3月20日-暑期实习-安排座位

https://codefun2000.com/p/P2336

##### 重要知识点
- 解题思路
- 二进制枚举法


**解题思路**

本题可以说是一道模拟题，主要的难点在于理解题意，根据题目提供的范围判断出我们可以利用暴力方法来求解。

以及利用二进制位来枚举所有可能的乘客组合。



**二进制枚举法**

1. **核心思想：用开关模型理解组合选择。**

    想象你的面前有一排01开关，每个开关控制一个乘客是否被选中：

    - 开关数量 = 乘客数（比如3个乘客 --> 3个开关）；
    - 开关状态：开（1）表示选该乘客，关（0）表示不选；
    - 所有可能组合：总共有2^n种（如3个开关 --> 8种组合）

    示例：

    - 011 --> 选中第1、2位乘客；
    - 101 --> 选中第0、2位乘客

2. **二进制数如何表示组合？**
    - 每位对应一个乘客：二进制的第*j*位代表，第j位乘客是否被选中；
    - 生成所有组合：遍历从*0*到*(2^x)-1*的所有整数，每个整数对应一个二进制组合。
    - 代码关键
        ```Python
        for i in range(1<<x): #生成所有组合，如x=3 -> 0到7（000到111）
        ```

3. **如何判断某位乘客是否被选中？**
    - 右移操作：将组合数右移*j*位，使得第*j*位变成最低位。
        ```Python
            i>>j # 示例：i=5(101), j=1 -> 101 >> 1 = 10（二进制）
        ```
    - 按位与1:提取最低位是否为1。
        ```Python
            if (i>>j) & 1: #结果为1 -> 选中， 0 -> 未选中
        ```
4. **具体操作：更新站点计数与合法性检查**
    - 更新站点计数：对于每个被选中的乘客，在其乘坐的站点区间*[s, e-1]*内计数+1.
    ```Python
        for k in range(s, e):#注意是e-1，因为下车站不占用
            cnt[k]+=1
    ```
    - 合法性检查：遍历所有站点，检查是否有站点计数超过座位数m。
    ```Python
        if cnt[j]>m:
            ok=False
            break
    ```
5. **优缺点与适用场景**
    - 优点
        - 实现简单，逻辑直观
        - 适合小数据量
    - 缺点
        - 时间复杂度 O(x*(2^x))，x大时指数爆炸
    - 替代方案
        - x较大时改用贪心（按区间排序）或动态规划
    
**总结记忆模版**
1. 问题场景：需要暴力尝试所有可能的组合，且数据量较小；
2. 核心工具:二进制数的每一位表示一个元素的选中状态；
3. 判断选中:(i>>j)&1
4. 实战技巧：
    - 预处理所有组合 --> for i in range(1 << x)
    - 遍历元素 --> for j in range(x)
    - 更新状态 --> 位运算 + 条件判断

比喻记忆：把每个组合想象成一组开关，遍历所有开关状态，选出最优解！


```Python
def solve():
    # 读取输入：座位数m，站点数n，乘客数x
    m,n,x=map(int,input().strip().split())
    # 读取所有乘客的上下车站点，存入列表a
    a=[]
    for _ in range(x):
        a.append(list(map(int,input().split())))
        
    # 初始化最大利用率ans为0
    ans=0
    
    # 枚举所有可能的乘客组合（二进制位表示）
    for i in range(1<<x):
        # 初始化每个站点的乘客计数数组cnt
        cnt=[0]*n
        # 标记当前组合是否合法
        ok=True
        # 当前组合的总利用率res
        res=0
        # 遍历所有乘客，判断是否被选中
        for j in range(x):
            # 如果乘客j被选中：
            if (i>>j)&1:
                # 获取乘客的上下车站点s和e
                s,e=a[j][0],a[j][1]
                # 在乘客占用的所有站点区间[s, e-1]上增加计数
                for idx in range(s,e):
                    cnt[idx]+=1
                # 累加该乘客的利用率到res
                res+=(e-s)
        # 检查所有站点的乘客数是否超过m
        for i in range(n):
            # 如果发现超载，标记为非法
            if cnt[i]>m:
                ok=False
                break
        # 如果组合合法，更新最大利用率ans
        if ok:
            ans=max(ans,res)
    # 输出答案
    print(ans)

if __name__ == "__main__":
    solve()
```




### [2024年3月20日](https://codefun2000.com/p/P2337)
#### 任务要求
#### 华为-2024年3月20日-暑期实习-积木塔

https://codefun2000.com/p/P2337

##### 重要知识点
- 解题思路
- 合并条件的处理逻辑
- 循环合并机制


**解题思路**

本题还是一道模拟题。本题的思路不难想。

- 问题本质：通过栈模拟积木塔的添加过程，每次添加新积木后立即检查并合并符合条件的积木块，直到无法合并为止。
- 关键技巧：在栈上直接操作，避免复制或临时存储，减少内存和时间开销。

**合并条件的处理逻辑**
- 条件1:新积木与栈顶相等
    - 操作：弹出栈顶元素，将新积木值翻倍
    - 示例：栈顶为3，新积木为3 --> 合并后放入6

- 条件2:新积木等于连续多块栈顶的和
    - 操作：从栈顶开始累加，找到连续和为当前值的积木块，弹出这些块合并
    - 示例：栈为[2, 1, 3],新积木为3 --> 合并1+2=3 --> 新栈为[3, 3] --> 继续合并为6。

**循环合并机制**
- 实现方式： 使用`while True`循环包裹合并逻辑，确保每次合并后重新检查条件。
- 终止条件：当无法满足任一合并条件时，退出循环并添加当前值到栈中。



**代码实现**
```Python
arr=list(map(int, input().strip().split()))
stack=[]


for item in arr:
    flag=True#标记是否继续遍历

    #当栈中的元素和大于当前遍历元素 且 标记变量为True时，持续遍历
    while flag and sum(stack[:])>=item:
        res=0#初始化累加和
        cnt=0#初始化计数器

        #反向遍历栈中的元素
        for sv in stack[::-1]:
            res+=sv
            cnt+=1
            if res==item:#如果累加和等于当前元素item
                for _ in range(cnt):
                    item+=stack.pop()#从栈中弹出cnt个元素并将其累加到x上
                break#跳出循环
            elif res>item:#如果累加和超过了当前元素
                flag=False
                break
                #设置标志为False,退出循环
    #将当前元素x添加到栈中
    stack.append(item)
        
#输出结果
print(*stack[::-1])
```



### [2025年2月19日](https://codefun2000.com/p/P2653)
#### 任务要求
#### 华为-2025年2月19日-暑期实习-循环依赖
https://codefun2000.com/p/P2653

##### 重要知识点
- 解题思路


**解题思路**

没太搞懂，抄了遍答案

**代码实现**
```Python
#构建有向图（用邻接表存储边的关系）
MAX=10000
n=int(input())
g=[[] for i in range(MAX)]
vis=[0]*MAX#已经访问过的元素
in_stk=[0]*MAX#记录当前路径是否有环

#知识点1：邻接表的构建-->构建一个二维数组，二维数组中的索引代表当前节点，当前节点所对应的数组中的元素为依赖的节点
for i in range(n):
    a=list(map(int,input().split()))
    for j in range(2, len(a)):
        g[a[1]].append(a[j])

stk=[]
t=[]

def dfs(u):
    #这个点在本次遍历或者之前的某次遍历中被遍历过了
    if vis[u]:
        #如果在栈中，说明本次遍历中被遍历过了
        if len(stk)>0 and in_stk[u]:
            #弹出元素直至弹出u
            while len(stk)>0 and stk[-1]!=u:
                in_stk[stk[-1]]=0#将栈中的元素标记为没被遍历过
                t.append(stk[-1])#用于存储环中的节点
                stk.pop()#从栈中删除该节点
            ##处理起点u
            in_stk[u]=0#取消u在栈中的状态
            stk.pop()#从stk移除u,表示u也被处理完毕
            t.append(u)#将u也加入t中，保证环的完整性
            #找到环了，根据题意有且仅有一个环，直接退出
            return True
        else:
            return False
    vis[u]=1#标记u为访问过的节点
    stk.append(u)#
    in_stk[u]=1
    for v in g[u]:
        if dfs(v):
            return True
    in_stk[u]=0
    #这个点不在环上，需要从栈中弹出
    stk.pop()
    return False


cnt =0
for i in range(1, MAX):
    #依次遍历所有还未被遍历过的点
    if not vis[i]:
        if dfs(i):
            cnt+=1

if cnt>1:
    print("oh no")


if len(t)>0:
    #弹出栈中的点获得的是一个倒序的环，需要反转一下
    t.reverse()
    minv=min(t)
    i=0
    while i<len(t):
        if t[i]==minv:
            break
        i+=1
    ans=t[i:]+t[:i]
    ans.append(t[i])
    print(*ans)
```

