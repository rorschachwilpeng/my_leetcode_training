# 大厂真题
## 拼多多
### [2025年3月23日](https://codefun2000.com/p/P2736)
#### 任务要求
#### 拼多多-2025年3月23日-算法岗位-推箱子（简单难度）
https://codefun2000.com/p/P2736

##### 重要知识点
- 简单模拟题，没啥好说的

**代码实现**

```Python
T=int(input())

for _ in range(T):
    x,y=map(int,input().strip().split())
    ops=input().strip()
    
    for op in ops:
        if op=='W':#向上
            y+=1
        elif op=='S':#向下
            y-=1
        elif op=='A':#向左
            x-=1
        elif op=='D':#向右 
            x+=1
    
    if x==0 and y==0:
        print('YES')
    else:
        print('NO')

```

### [2025年3月23日](https://codefun2000.com/p/P2739)
#### 任务要求
#### 拼多多-2025年3月23日-算法岗位-新型彩票（困难难度）

##### 重要知识点
- 暴力解法
- 鸽巢原理
- 二分法
- 二分法解题思路

**暴力解法**

暴力解法就是遍历字符串连续拼接的可能子串。然后逐个判断这些子串是否为幸运数。无法通过全部样例。

-----

**鸽巢原理**

*鸽巢原理及其在这题中的应用*

*什么是鸽巢原理？*
鸽巢原理是一个很简单的数学思想，用大白话说就是：“如果你有 5 只鸽子，但只有 4 个笼子，那么至少有一个笼子会装下 2 只鸽子。”  
更一般地，如果有 \(n\) 个东西要放进 \(m\) 个容器，且 \(n > m\)，那么至少有一个容器会装至少 2 个东西。

*在这题中怎么用？*
这题要判断一个数字是否是“幸运数字”，即它的某个连续子串是否是 3 的倍数。我们发现，**3 位数及以上的数字一定是幸运数字**，原因就用到了鸽巢原理。

具体来说：
- 一个数字是否是 3 的倍数，可以通过它的各位数字之和模 3 判断，模 3 的结果只有 0、1、2 三种可能（就像 3 个“笼子”）。
- 对于一个 \(d\) 位数字（\(d \geq 3\)），我们从左到右逐位累加，计算前缀和模 3 的值，总共有 \(d+1\) 个前缀和（包括初始的 0），比如 3 位数有 4 个前缀和（就像 4 只“鸽子”）。
- 因为 4 > 3（鸽子比笼子多），根据鸽巢原理，必然有 2 个前缀和的模 3 值相同。
- 假设在位置 \(i\) 和 \(j\)（\(i < j\)）的前缀和模 3 相同，那么从位置 \(i+1\) 到 \(j\) 的子串的和模 3 就是 0，也就是 3 的倍数。
- 举个例子：数字 111（3 位数）：
  - 前缀和模 3：0, 1, 2, 0（0+1=1, 1+1=2, 2+1=3 模 3=0）。
  - 模 3 的值 0 出现了两次（初始和最后），说明子串 111 的和模 3 是 0，即 111 是 3 的倍数。
- 因此，3 位数及以上的数字必然有一个连续子串是 3 的倍数，必定是幸运数字。

*为什么这很重要？*
有了这个结论，我们只需要判断 1 位数和 2 位数是否是幸运数字，3 位数及以上直接算作幸运数字，大大降低了计算量。

--- 

**二分法**

这题中，我们用二分法（通过 Python 的 `bisect` 模块）快速统计 \([L, R]\) 区间内 2 位数的非幸运数字数量。  
具体做法是：预先将所有 2 位非幸运数字存入有序列表 `valid`，然后用 `bisect_left` 和 `bisect_right` 找到 \([L, R]\) 在 `valid` 中的左右边界，计算区间内非幸运数字个数。  
二分法将查找复杂度从 \(O(n)\) 降到 \(O(\log n)\)，效率更高。

---

**二分法解题思路**

与其像暴力法中直接判断数字是否为幸运数，我们可以反其道而行之，通过判断数字是否为非幸运数。然后利用**幸运数 = 总数 - 非幸运数**公式来计算幸运数数量。

为什么判断非幸运数的方法会比判断幸运数的方法时间复杂度低呢？
1. “鸽巢原理” --> 三位数及以上的数字的连续子串中一定包含3的倍数，这意味着我们只需要判断一位数和两位数的情况即可；
2. 1 位数和 2 位数的判断很简单，数量少，处理快；

具体实现方法：

1. 先构造两位数的非幸运数组，里面的数字都是两位数的非幸运数字；
2. 前提：三位数（或以上）的数一定有3的倍数的连续子串，因此只判断一位数和二位数
3. 判断一位数：判断一位数区间内有多少非幸运数字 --> count1
4. 判断二位数：判断二位数区间内有多少非幸运数字 --> count2
5. 计算幸运数字：根据公式**幸运数 = 总数 - 非幸运数**，且“非幸运数=count1+count2”，求解最终“幸运数”。

``` Python
import bisect
#1.构建两位数的非幸运数组
valid=[]
for i in [1,2,4,5,7,8]:
    for j in [1,2,4,5,7,8]:
        if i%3==j%3:
            valid.append(i*10+j)
valid.sort()

#2.前提：根据鸽巢原理可推，三位数及以上的连续子串一定包含3的倍数
T=int(input())
for _ in range(T):
    #3.计算一位数中的非幸运数字
    L,R=map(int,input().strip().split())
    total=R-L+1
    start1=max(L,1)
    end1=min(R,9)
    count1=0
    if start1<=end1:#保证在一位数的范围内
        total1=end1-start1+1
        unlucky_cnt=(end1//3)-((start1-1)//3)
        count1=total1-unlucky_cnt#计算一位数范围中的非幸运数字
    
    #4.计算两位数中的非幸运数字
    start2=max(L,10)
    end2=min(R,99)
    count2=0
    if start2<=end2:#保证在二位数的范围内
        l=bisect.bisect_left(valid,start2)
        r=bisect.bisect_right(valid,end2)
        count2=r-l
    #幸运数字数量 = 总数量 - 非幸运数量（一位数非幸运数量 + 两位数幸运数量）
    lucky=total-(count1+count2)
    print(lucky)
```


### [2025年3月23日](https://codefun2000.com/p/P2738)
#### 任务要求
#### 拼多多-2025年3月23日-算法岗位-身高排列（中等难度）
https://codefun2000.com/p/P2738

##### 重要知识点
- 利用单调栈来实现
- 反思

**利用单调栈来实现**

创建并维护一个单调递增（从栈底-->栈顶）的单调栈，栈中的元素代表了同学的索引。

*伪代码*
```Python
从右往左遍历同学：
    当栈中有元素而且栈顶的同学小于当前同学时候：
        弹出栈顶元素（因为这些同学都比当前同学矮）
    
    接下来我们需要计算，对于当前同学，有多少同学比他矮
    if 栈不为空的话：
        那么栈顶同学就是第一个比当前同学高同学 --> 当前同学能够看到的同学数为：stack[-1]-i (这里的计算体现了利用索引作为栈中元素的巧妙之处)
    if 栈为空的话：
        那么当前同学能看到其之后所有的同学 --> 当前同学能够看到的同学数为: n-i-1 (这里的计算体现了利用索引作为栈中元素的巧妙之处)

    累加数量
    将当前元素加入到栈中
打印结果
```



**反思**

1. 这道题过了60%的样例，主要是因为超时引起的。做的时候一直卡在重复记录元素/漏掉元素上。根本原因是因为没有想到可以利用“索引”作为栈中的元素，而是一直在尝试利用“元组（元素值，比其大的元素数量）”来做。
2. 不要死背题，而是要理解和记住本题中利用单调栈和索引来巧妙解决的思路。



**代码实现**
```Python
#维护一个单调栈
#栈中的元素代表了同学的索引，这个单调栈是一个单调递增栈（从栈尾到栈顶）
n=int(input())
h=list(map(int,input().strip().split()))
stack=[]
res=0

for i in range(n-1,-1,-1):
    cnt=0
    while stack and h[stack[-1]]<h[i]:
        stack.pop()
    if stack:
        cnt=stack[-1]-i
    else:
        cnt=n-i-1
    res+=cnt
    stack.append(i)
print(res)
```



### [2025年3月23日](https://codefun2000.com/p/P2739)
#### 任务要求
#### 拼多多-2025年3月23日-算法岗位-字符串替换（中等难度）
https://codefun2000.com/p/P2739

##### 重要知识点
- 其实可以算一道模拟题

**其实可以算一道模拟题**

这道题的核心其实很简单，如果想要最后S1的字典序小的话，那么就尽可能地将小的字母换到A的前面。
1. 因此，我们需要将字符串B按照字母顺序重新排序。
2. 我们需要将字符尽可能地换到字符串A中的前面的字母。为了达到这个目的，我们首先需要知道字符串A中有哪些位置的元素需要**被替换**。然后我们对需要**被替换**的元素按照索引进行重新排序，即可尽可能地将元素替换到字符串A的前面


**代码实现**
```Python
T=int(input())
for _ in range(T):
    #第一行输入n,m；n-->字符串A的长度；m-->字符串B的长度
    n,m=map(int,input().strip().split())

    strA=str(input())#字符串A
    strB=str(input())#字符串B
    
    X=list(map(int,input().strip().split()))#输入数组

    #利用一个数组来表示，数组索引代表A中元素的位置，而值代表该位置的元素需要被替换的次数
    cnt=[0]*(n+1)
    for i in X:
        cnt[i]+=1

    #再新建一个数组positions，用来记录需要被遍历的元素的位置
    positions=[]
    for j in range(1,n+1):
        if cnt[j]>0:
            positions.append(j)        
    #将positions进行排序-->代表A中需要 被替换 的元素
    positions.sort()

    #2，将B中的元素按升序排序，代表需要替换的元素
    sorted_B=sorted(strB)
    
    #进行替换
    K=len(positions)#需要被替换的元素的数量
    res=list(strA)#初始化结果字符
    for i in range(K):
        pos=positions[i]#需要被替换的位置 from A
        res[pos-1]=sorted_B[i]#替换的元素 from B
    print(''.join(res))
```