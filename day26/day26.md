# 代码随想录
## 回溯算法
### [《代码随想录》回溯算法：重新安排行程](https://notes.kamacoder.com/questions/502037)
#### 任务要求

#### 332. 
    重新安排行程（可跳过）

本题很难，一刷的录友刷起来 比较费力，可以留给二刷的时候再去解决。
本题没有录制视频，当初录视频是按照 《代码随想录》出版的目录来的，当时没有这道题所以就没有录制。
https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html


##### 重要知识点

- 困难题不难
- 本题难点
- 用什么数据结构来存储航班信息？
- 怎么避免死循环？
- 递归中的终止条件是？



**困难题不难**

不能在心态上被困难题吓到，困难题其实也不过就是两道中等题加在一起，中等题其实也不过就是两道简单题加在一起。都是一步一步分析做出来了。


**本题难点**

本题是DFS的思路来做，重点难点包括：

1. 用什么数据结构来存储航班信息？
2. 怎么避免死循环？
3. 递归中的终止条件是？
4. 怎么递归？这次递归需要返回值吗？



**用什么数据结构来存储航班信息？**

字典是最优选项，因为需要存储的出发地和目的地都是string数据类型，且可能存在一对多的映射关系。所以可以利用字典，key是出发地，value是目的地（可能存在多个）数组。



**怎么避免死循环？**

每次递归过程中，一旦确定下一个目的地后，将其从对应的航班信息中弹出，避免重复遍历造成死循环。


**递归中的终止条件是？**

这点我的理解有点模糊，代码随想录上说的是“回溯遍历的过程中，遇到的机场个数，如果达到了（航班数量+1），那么我们就找到了一个行程，把所有航班串在一起了。”

但是在代码实现中，没有看到具体步骤。

我自己的理解是在树形结构中找到一条能够覆盖所有航班信息（节点）路径的通路。

- CHATGPT给的解释：

```
终止条件的隐式设计

递归没有显式的 `return` 语句，因为路径的记录通过全局变量 `result` 实现，而递归终止是通过以下逻辑完成的：
1. 没有更多的目的地可以访问时，当前递归自然退出。
2. 通过回溯，依次将每个节点添加到 `result` 中，最终形成完整的行程。
```


**怎么递归？这次递归需要返回值吗？**

不需要返回值，因为我们目标返回的数组可以通过维护全局变量完成。



**代码**

```
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        self.adj={}#字典，用于存储航班信息；key-出发地,val:目的地
        
        tickets.sort(key=lambda x:x[1])#将航班信息按照字母顺序重新排序

        for u,v in tickets:
            if u in self.adj:
                self.adj[u].append(v)
            else:
                self.adj[u]=[v]

        result=[]
        def dfs(ori):#入参 --> 出发地
            while ori in self.adj and self.adj[ori]:
                des=self.adj[ori][0]#找到下一个目的地
                self.adj[ori].pop(0)#弹出目的地，确保不重复遍历
                dfs(des)
            result.append(ori)
        dfs("JFK")
        return result[::-1]
```